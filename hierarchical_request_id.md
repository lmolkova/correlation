#  Hierarchical Request-Id
This document provides extension for [HTTP protocol proposal](http_protocol_proposal_v1.md) for telemetry correlation.

## Overview
The main requirement for Request-Id is uniqueness, any two requests processed by the same cluster must not collide within reasonable amount of time.
Guids or big random number help to achieve it, but they require other identifiers to querly all requests related to the operation.

Hierarchical Request-Id look like `/<root-id>.<local-id1>.<local-id2>` (e.g. `/b82371c7da4e9679.bcec871c.1`) and holds all information needed to trace whole operation and particular request.
Root-id serves as common identifier for all requests involved in operation processing and local-ids represent internal activities (and requests) done within scope of this operation.

[CorrelationVector](https://osgwiki.com/wiki/CorrelationVector) is a valid hierarchical Request-Id as defined by this document.

If `Request-Id` was not provided and implementation decides to instrument the request,
it MUST generate new `Request-Id` (see [Root Request Id Generation](http_protocol_proposal_v1.md#root-request-id-generation))
to represent incoming request.
If `Request-Id` is provided from upstream service, implementation MUST append small id preceded with separator 
and pass it to downstream service, making sure every outgoing request has different suffix.
See [Formatting Hierarchical Request-Id](#formatting-hierarchical-request-Id) for more details.

In heterogenious environment implementations with hierarchical `Request-Id` may interact 
with implementations which do not support it. Implementation or logging system should be able unambiguously identify if given `Request-Id` has hierarchical schema.

Therefore every implementation which support hierarchical structure MUST prepend "/" symbol to generated `Request-Id`.

#### Formatting Hierarchical Request-Id
`Request-Id` has following schema:

ParentId.LocalId

**ParentId** is Request-Id passed from upstream service (or generated if was not provided), it may have hierarchical structure itself.

**LocalId** is generated to identify internal operation or outgoing request. It may have hierarchical structure too, considering service or protocol implementation may split operation to multiple activities <sup>1</sup>.
- LocalId MUST be unique for every outgoing HTTP request sent while processing the incoming request. 
- LocalId MUST contain only [Base64 characters](https://en.wikipedia.org/wiki/Base64), "-", and ".".
- LocalId SHOULD be small to reduce possibility of `Request-Id` overflow. For the outgoing request, number of request within the scope of this operation, may be a good candidate.

ParentId and LocalId are separated with "." delimiter.

<sup>1</sup>Since ParentId comes from external process there is no guarantee that it is unique. Implementation SHOULD normilize it by adding small (e.g. 32 bits random integer) suffix to perresent Id for internal activity.
When outgoing request is made, `Request-Id` for it may be generated by another suffix as described above for LocalId: `ParentId.SaneSuffix.RequestCounterSuffix`, so LocalId would become `SaneSuffix.RequestCounterSuffix` and have hierarchical structure.

Appending LocalId may cause `Request-Id` to exceed length limit.

##### Request-Id Overflow
To handle overflow, implementation 
* MUST generate such LocalId that keeps possibility of collision with any of the previous or future Request-Id within the same operation neglectable.
* MUST prepend LocalId with "#" symbol to indicate that overflow happened.
* MUST trim end of existing Request-Id to make a room for generated LocalId. Implementation MUST trim whole nodes (separated with ".") with preceeding "." ore previous overflow LocalId with preceeding "#", i.e. it's invalid to trim only part of node. 
- LocalId MUST contain only [Base64 characters](https://en.wikipedia.org/wiki/Base64) and "-".

As a result Request-Id will look like: 

  `Beginning-Of-Parent-Request-Id#LocalId`

Thus, to the extent possible, Request-Id will keep valid part of hierarchical Id.

LocalId should be large enough to ensure new Request-Id does not collide with one of previous/future Request-Ids within the same operation. Using random 4 bytes integer is a good candidate for LocalId.

Note that applications could asynchronously start multiple outgoing requests almost at the same time, which makes timestamp even with ticks precesion bad candidate for LocalId.
